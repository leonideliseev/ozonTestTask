package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"fmt"
	"strconv"

	"github.com/leonideliseev/ozonTestTask/graph/model"
	smodel "github.com/leonideliseev/ozonTestTask/pkg/model"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
	uid, err := strconv.ParseUint(input.UserID, 10, 32)
	if err != nil {
		return nil, err
	}

	newPost := smodel.CreatePost{
		Title:           input.Title,
		Content:         input.Content,
		UserId:          uint(uid),
		CommentsEnabled: input.CommentsEnabled,
	}

	post, err := r.storage.CreatePost(newPost)
	if err != nil {
		return nil, err
	}

	return post.ToGraphQL(), nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.CreateCommentInput) (*model.Comment, error) {
	uid, err := strconv.ParseUint(input.UserID, 10, 32)
	if err != nil {
		return nil, err
	}

	pid, err := strconv.ParseUint(input.PostID, 10, 32)
	if err != nil {
		return nil, err
	}

	var parid *uint
	if input.ParentCommentID != nil {
		parid64, err := strconv.ParseUint(*input.ParentCommentID, 10, 32)
		if err != nil {
			return nil, err
		}
		paridu := uint(parid64)
		parid = &paridu
	}

	// проверка на длину комментария
	text := []rune(input.Content)
	if len(text) > 2000 {
		return nil, fmt.Errorf("very long comment, simvol lenght = %d > 2000", len(text))
	}

	newComment := smodel.CreateComment{
		Content:  input.Content,
		UserId:   uint(uid),
		PostId:   uint(pid),
		ParentId: parid,
	}

	comm, err := r.storage.CreateComment(newComment)
	if err != nil {
		return nil, err
	}

	// уведомление подписчиков о новом комментарии под постом
	r.NotifySubscribers(input.PostID, comm.ToGraphQL())

	return comm.ToGraphQL(), nil
}

// CreateUser is the resolver for the CreateUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, username string) (*model.User, error) {
	newUser := smodel.CreateUser{
		Username: username,
	}

	user, err := r.storage.CreateUser(newUser)
	if err != nil {
		return nil, err
	}

	return user.ToGraphQL(), err
}

// GetPosts is the resolver for the getPosts field.
func (r *queryResolver) GetPosts(ctx context.Context, limit *int, offset *int) (*model.PostPage, error) {
	lim, off := setLimOff(limit, offset)

	badPostPage, err := r.storage.GetPosts(lim, off)
	if err != nil {
		return nil, err
	}

	dirtyPosts := badPostPage.Posts
	posts := make([]*model.Post, 0, len(dirtyPosts))
	for _, dirtyPost := range dirtyPosts {
		post := dirtyPost.ToGraphQL()
		posts = append(posts, post)
	}

	postPage := &model.PostPage{
		Posts:      posts,
		TotalCount: badPostPage.TotalCount,
	}

	return postPage, nil
}

// GetPost is the resolver for the getPost field.
func (r *queryResolver) GetPost(ctx context.Context, id string, limit *int, offset *int) (*model.Post, error) {
	lim, off := setLimOff(limit, offset)

	pid, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, err
	}

	post, err := r.storage.GetPost(lim, off, uint(pid))
	if err != nil {
		return nil, err
	}

	return post.ToGraphQL(), nil
}

// GetComments is the resolver for the getComments field.
func (r *queryResolver) GetComments(ctx context.Context, commID string, limit *int, offset *int) (*model.Comment, error) {
	lim, off := setLimOff(limit, offset)

	cid, err := strconv.ParseUint(commID, 10, 32)
	if err != nil {
		return nil, err
	}

	comm, err := r.storage.GetComments(lim, off, uint(cid))
	if err != nil {
		return nil, err
	}

	/*dirtyComms := dirtyComm.Replies.Comms
	comms := make([]*model.Comment, 0)
	for _, dirtyComm := range dirtyComms {
		comm := dirtyComm.ToGraphQL()
		comms = append(comms, comm)
	}*/

	return comm.ToGraphQL(), nil
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	comments := make(chan *model.Comment, 1)

	r.mu.Lock()
	r.subscribers[postID] = comments
	r.mu.Unlock()

	// когда контекст завершится, то произойдёт удаление подписки к посту
	go func() {
		<-ctx.Done()
		r.mu.Lock()
		delete(r.subscribers, postID)
		r.mu.Unlock()
	}()

	return comments, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *Resolver) NotifySubscribers(postId string, comment *model.Comment) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	if subscriber, ok := r.subscribers[postId]; ok {
		subscriber <- comment
	}
}
func setLimOff(limit, offset *int) (int, int) {
	var lim, off int

	if limit == nil {
		lim = 20
	} else {
		lim = *limit
	}

	if offset == nil {
		off = 0
	} else {
		off = *offset
	}

	return lim, off
}
