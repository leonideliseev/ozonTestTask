# Документация к использованию приложения
## Запуск приложения локально
```
go run cmd/server.go
```
Перед запуском можно локально создать файл .env и указать там переменные окружения:
1. APP_PORT - по умолчанию 8080
2. HOST_PORT - по умолчанию 8080
3. DB_STORE - по умолчанию false. Выбор использования приложения через in-memory или PostgreSQL реализцию хранения данных. Для использования хрфнения в бд необходимо указать true, при любом другом вводе будет false. 
4. DATABASE_URL - для подключения к базе, загружается если DB_STORE выбрано true

## Поддерживаемые запросы в GraphQL
### Mutation:
1. ```createPost(input: CreatePostInput!): Post!``` - создаёт пост с данными, которые необходимы для ввода. Возвращает пост. Необходим уже созданный пользователь.
2. ```createComment(input: CreateCommentInput!): Comment!``` - создаёт комментарий для поста или другого комментария. Возврашает комментарий. Необходимы созданные пользователь и пост.
3. ```createUser(username: String!): User!``` - создаёт пользователя по username. Возвращает пользователя.
### Query:
1. ```getPosts(limit: Int, offset: Int): PostPage!``` - возвращает список постов, !без! комментариев под ними. Поддерживает пагинацию.
2. ```getPost(id: ID!): Post!``` - возвращает пост с комментариями по ID поста.
3. ```getComments(commId: ID!): [Comment!]!``` - возвращает список комментариев, по ID комментария. (на данный момент пагинация не доделана)
### Subscription:
1. ```commentAdded(postId: ID!): Comment!``` - позволяет пользователю подписаться на уведомления о создании комментария под постом по ID поста. Выполняется асинхронно без необходимости повторного запроса.
# Особенности работы приложения
## Ограничение вложенности при получении
В данном приложении ограничена максимальная вложенность комментариев до 5 при выполнении getPost и getComments. Сделано с целью, если где-то будет слишком большая вложенность.
Если необходимо получить дальнейшие по вложенности комментари, которые будут отвечать на последний, следует выполнить

```getComments(commId: "<id последнего комментария>") {}```
## Учёт проблемы n+1
В приложении для работы с бд используется пакет gorm, который представляет из себя ORM для Golang. Данная библиотека автоматизирует запросы так, что проблема n+1 не возникает.

Например, если выполнять запрос на getPosts, то у постов содержатся авторы. Проблема n+1 заключалась бы в том, что получив список постов, потом было бы необходимо для каждого поста получить связанного по userID пользователя, написавшего этот пост.
За счёт использования готовой реализации получения данных из бд в виде gorm, данная проблема не возникнет.
## Переменные окружения
Присутствуют необходимые для запуска переменные окружения. Через них можно выбрать способ зранения данных, а также указать порты. Имеют значения по умолчанию. В случае, если надо изменить необходимо создать .env файл.
При запуске докера можжно указать через -e.

P.S. переменная DATABASE_URL также задана по умолчанию, что, вообще, не совсем правильно. По сути если запускать приложение с DB_STORE=true и не указывать эту перемнную, то должна быть ошибка.
# Запуск приложения через docker
## Используя docker run
Приложение имеет docker-image по [ссылке](https://hub.docker.com/repository/docker/lenev/ozon-task-image/general).
Для запуска необходимо установить изображение:

```docker push lenev/ozon-task-image:<tagname>``` (tagname - latest)

Далее запустить командой:

```docker run -p 8080:8080 -d --rm docker push lenev/ozon-task-image:<tagname>```

Можно указать переменные окружения, используя -e VAR=

Если запустить приложение с DB_STORE=true необходимо указать DATABASE_URL до развёрнутой базы данных PostgresQL. Если база планируется быть запущенной в докере, то необходимо настроить соединение между контейнерами черех network.
## Используя docker-compose up
Данное приложение содержит настроенный docker-compose.yml файл, а потому можно просто выполнить следующую команду из корневой директории проекта:
```docker-compose up```
После будут созданы образы приложения и postgres с уже настроенным подключением между ними.
